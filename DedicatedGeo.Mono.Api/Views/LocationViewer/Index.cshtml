@model DedicatedGeo.Mono.Dtos.Web.LocationPathViewDto

@{
    ViewBag.Title = Model.Title;
}

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
    html, body, #map { height: 100vh; margin: 0; padding: 0; }

    /* make the Details button match the datetime picker / sidebar look */
    #openSidebar {
        position: absolute;
        top: 12px;
        right: 20px;
        z-index: 1104;
        background: rgba(11,18,28,0.85);
        color: #e6eef8;
        border: 1px solid rgba(255,255,255,0.04);
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    .sidebar-backdrop{
        position: fixed;
        inset: 0;
        background: transparent;
        z-index: 1100;
        opacity: 0;
        pointer-events: none;
        transition: opacity .18s ease, background-color .18s ease;
    }
    .sidebar-backdrop.open{
        opacity: 0;
        pointer-events: auto;
    }

    .sidebar{
        position: fixed;
        top: 0;
        right: 0;
        height: 100vh;
        width: min(520px, 92vw);
        /* align sidebar look with the picker: slightly translucent dark surface */
        background: rgba(11,18,28,0.8);
        box-sizing: border-box;
        overflow: hidden;
        box-shadow: -30px 0 60px rgba(2,6,23,0.6);
        transform: translateX(105%);
        transition: transform .28s cubic-bezier(.2,.9,.25,1);
        z-index: 1202;
        display: flex;
        flex-direction: column;
        padding: 18px;
        gap: 12px;
        font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        color: #e6eef8;
        border-left: 1px solid rgba(255,255,255,0.03);
    }
    .sidebar.open{ transform: translateX(0); }

    .sidebar-header, .section { flex: 0 0 auto; }
    
    #pointsSection{
        display: flex;
        flex-direction: column;
        flex: 1 1 auto;
        min-height: 0;
        overflow: hidden;
    }

    .points-container{
        display:flex;
        flex-direction:column;
        gap:8px;
        overflow-y:auto;
        overflow-x:hidden;
        flex: 1 1 auto;
        min-height: 0;
        padding-bottom:6px;
        width:100%;
    }

    #statusSection{
        flex: 0 0 auto;
    }

    .sidebar-header{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .title{ display:flex; align-items:center; gap:12px; }
    .title .dot{ width:42px;height:42px;border-radius:10px; background: linear-gradient(135deg,#7c5cff,#5ab3ff); display:flex;align-items:center;justify-content:center;font-weight:700; }
    .title h3{ margin:0; font-size:16px; }
    .close-btn{ background:transparent;border:none;color:#9aa4b2;cursor:pointer;padding:8px;border-radius:8px; }

    .section { background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.03)); border-radius:12px; padding:12px; border:1px solid rgba(255,255,255,0.03); }
    .section h4{ margin:0 0 8px 0; font-size:13px; color:#dfe8f7; display:flex;justify-content:space-between; align-items:center; }
    .section .count{ font-size:12px; color:#9aa4b2; }

    .group{
        width:100%;
        display:flex;
        flex-direction:column;
        gap:8px;
    }
    .point{ background: rgba(255,255,255,0.03); border-radius:8px; padding:8px; font-size:12px; color:#e6eef8; box-shadow:0 4px 14px rgba(4,6,12,0.35); border:1px solid rgba(255,255,255,0.02); }
    .point .meta{ color:#9aa4b2; font-size:11px; margin-top:6px; }

    .point:hover { cursor: pointer; transform: translateX(2px); }
    .point.selected{ border: 1px solid rgba(90,179,255,0.9); background: linear-gradient(180deg, rgba(90,179,255,0.06), rgba(90,179,255,0.02)); }

    .status-grid{ display:grid; grid-template-columns: repeat(2,1fr); gap:8px; margin-top:6px; }
    .status-item{ padding:10px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(0,0,0,0.04)); display:flex; flex-direction:column; gap:6px; font-size:13px; }
    .status-item .val{ font-weight:700; color:#fff; }
    .status-true{ color:#22c55e; font-weight:700; }
    .status-false{ color:#9aa4b2; font-weight:700; }

    .actions{ display:flex; gap:8px; align-items:center; }
    .btn{ padding:8px 12px; border-radius:9px; border:none; cursor:pointer; font-weight:600; }
    .btn.danger{ background: linear-gradient(180deg,#ef4444,#c81b1b); color:white; }

    .datetime-row{ display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    .datetime-row label{ font-size:12px; color:#9aa4b2; margin-right:6px; }
    .datetime-input{ background: rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.04); color:#e6eef8; padding:8px; border-radius:8px; }
    .datetime-input::-webkit-calendar-picker-indicator{ filter:invert(1) grayscale(1); }

    @@media (max-width:560px){
        .points-container{ flex-direction:column; }
        .group{ min-width:unset; }
    }
</style>

<div id="map"></div>

<!-- Top-center datetime picker moved from the sidebar -->
<div id="pickerContainer" style="position:absolute;top:12px;left:50%;transform:translateX(-50%);z-index:1103;display:flex;align-items:center;gap:8px;background:rgba(11,18,28,0.85);padding:8px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);">
    <label for="fromPicker" style="font-size:12px;color:#9aa4b2;margin-right:6px;">From</label>
    <!-- step="1" enables seconds in datetime-local input -->
    <input id="fromPicker" class="datetime-input" type="datetime-local" step="1" />
    <label for="toPicker" style="font-size:12px;color:#9aa4b2;margin-right:6px;">To</label>
    <input id="toPicker" class="datetime-input" type="datetime-local" step="1" />
</div>

<button id="openSidebar">Details</button>

<div id="backdrop" class="sidebar-backdrop" aria-hidden="true"></div>

<aside id="sidebar" class="sidebar" aria-hidden="true">
    <div class="sidebar-header">
        <div class="title">
            <div class="dot">LP</div>
            <div>
                <h3>Location Points</h3>
                <div style="font-size:12px;color:#9aa4b2">Live point summary</div>
            </div>
        </div>
        <div class="actions">
            <button id="deleteAll" class="btn danger">Delete all points</button>
            <button id="closeSidebar" class="close-btn" title="Close">✕</button>
        </div>
    </div>

    <!-- Points section: groups are purely presentational (not strict "zones") -->
    <div class="section" id="pointsSection">
        <h4>Points <span id="pointsCount" class="count"></span></h4>

        <div class="points-container" id="pointsContainer">
        </div>
    </div>

    <!-- Status section -->
    <div class="section" id="statusSection">
        <h4>Status <span id="statusUpdated" class="count"></span></h4>
        <div class="status-grid" id="statusGrid">
            <div class="status-item">
                <div class="label">Battery Level</div>
                <div id="BatteryLevel" class="val">—</div>
            </div>
            <div class="status-item">
                <div class="label">GPS Online</div>
                <div id="IsGPSOnline" class="val status-false">—</div>
            </div>
            <div class="status-item">
                <div class="label">In Alarm</div>
                <div id="IsInAlarm" class="val status-false">—</div>
            </div>
            <div class="status-item">
                <div class="label">Button Pressed</div>
                <div id="IsButtonPressed" class="val status-false">—</div>
            </div>
            <div class="status-item" style="grid-column:1 / -1; display:flex; justify-content:space-between; align-items:center;">
                <div style="font-size:13px;color:#9aa4b2">Updated At</div>
                <div id="lastFetched" style="font-size:12px;color:#9aa4b2">—</div>
            </div>
        </div>
    </div>
</aside>

<!-- scripts removed as requested -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    // Map initialization
    const map = L.map('map').setView([0,0],2);
    // Use CartoDB Positron (light) tiles for a clean, minimal basemap
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        subdomains: 'abcd',
        maxZoom: 19,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
    }).addTo(map);

    // state
    let mapMarkers = [];
    let mapPath = null;
    let didInitialFit = false;
    let selectedMarkerIndex = null;

    // helpers
    const toNum = v => { if (v === undefined || v === null) return null; const n = Number(String(v).replace(',', '.')); return Number.isFinite(n) ? n : null; };

    // parse timestamp values robustly (supports unix seconds, unix milliseconds, ISO strings and Date objects)
    function parseTimestamp(v) {
        if (v == null) return null;
        if (v instanceof Date) return v;
        if (typeof v === 'number') {
            // heuristic: values > 1e12 are milliseconds, otherwise seconds
            return new Date(v > 1e12 ? v : v * 1000);
        }
        if (typeof v === 'string') {
            // numeric string?
            if (/^\d+$/.test(v)) {
                const n = Number(v);
                return new Date(n > 1e12 ? n : n * 1000);
            }
            // If the server returned an ISO-like string without a timezone (e.g. "2023-10-05T12:00:00"),
            // some browsers may interpret that as local time while others treat it as UTC. To ensure
            // consistent behavior (treat timezone-less ISO as UTC and then display in the user's local timezone),
            // detect such strings and append a 'Z' before parsing.
            const isoNoTZ = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d{1,3})?$/.test(v);
            const parseInput = isoNoTZ ? (v + 'Z') : v;
            const d = new Date(parseInput);
            if (!isNaN(d)) return d;
        }
        return null;
    }

    // produce a datetime-local string like YYYY-MM-DDTHH:mm:ss
    function toDateTimeLocal(dt) {
        const pad = n => String(n).padStart(2, '0');
        return `${dt.getFullYear()}-${pad(dt.getMonth()+1)}-${pad(dt.getDate())}T${pad(dt.getHours())}:${pad(dt.getMinutes())}:${pad(dt.getSeconds())}`;
    }

    // Format a Date into a consistent, human-readable local-time string including seconds
    function formatLocal(dt) {
        if (!dt) return '—';
        try {
            const pad = n => String(n).padStart(2, '0');
            const mm = pad(dt.getMonth() + 1);
            const dd = pad(dt.getDate());
            const yyyy = dt.getFullYear();
            let hours = dt.getHours();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            if (hours === 0) hours = 12;
            const hh = pad(hours);
            const min = pad(dt.getMinutes());
            const sec = pad(dt.getSeconds());
            return `${mm}/${dd}/${yyyy} ${hh}:${min}:${sec} ${ampm}`;
        } catch (e) {
            // fallback to locale string if something unexpected occurs
            return dt.toLocaleString();
        }
    }

    // convert datetime-local (local time) or any ISO input to UTC ISO (no milliseconds, ends with Z)
    function localToISOString(localValue) {
        if (!localValue) return '';
        const m = localValue.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})(?::(\d{2}))?$/);
        let iso;
        if (m) {
            const y = Number(m[1]), mo = Number(m[2]) - 1, d = Number(m[3]);
            const hh = Number(m[4]), mm = Number(m[5]), ss = Number(m[6] || '0');
            const localDt = new Date(y, mo, d, hh, mm, ss);
            iso = localDt.toISOString();
        } else {
            iso = new Date(localValue).toISOString();
        }
        return iso.replace(/\.\d{3}Z$/, 'Z');
    }

    function setDefaultRange() {
        const now = new Date();
        const oneHourAgo = new Date(now.getTime() - 60*60*1000);
        const fromEl = document.getElementById('fromPicker');
        const toEl = document.getElementById('toPicker');
        if (fromEl && toEl) {
            if (!fromEl.dataset.userEdited) fromEl.value = toDateTimeLocal(oneHourAgo);
            if (!toEl.dataset.userEdited) toEl.value = toDateTimeLocal(now);
            if (!fromEl.dataset.userEdited) fromEl.dataset.auto = 'true';
            if (!toEl.dataset.userEdited) toEl.dataset.auto = 'true';
        }
    }

    function buildUrl() {
        let url = '/v1/public/location/points';
        const params = [];
        const fromEl = document.getElementById('fromPicker');
        const toEl = document.getElementById('toPicker');
        if (fromEl && fromEl.value) {
            const iso = localToISOString(fromEl.value);
            if (iso) params.push('from=' + encodeURIComponent(iso));
        }
        if (toEl && toEl.value) {
            const iso = localToISOString(toEl.value);
            if (iso) params.push('to=' + encodeURIComponent(iso));
        }
        if (params.length) url += '?' + params.join('&');
        return url;
    }

    function clearMap() {
        mapMarkers.forEach(m => { try { map.removeLayer(m); } catch(e) {} });
        mapMarkers = [];
        if (mapPath) { try { map.removeLayer(mapPath); } catch(e) {} mapPath = null; }
        selectedMarkerIndex = null;
    }

    async function loadPoints() {
        try {
            const fromEl = document.getElementById('fromPicker');
            const toEl = document.getElementById('toPicker');
            const now = new Date();
            if (fromEl && toEl && fromEl.dataset.auto === 'true' && toEl.dataset.auto === 'true') {
                const oneHourAgo = new Date(now.getTime() - 60*60*1000);
                fromEl.value = toDateTimeLocal(oneHourAgo);
                toEl.value = toDateTimeLocal(now);
            } else if (toEl && toEl.dataset.auto === 'true') {
                toEl.value = toDateTimeLocal(now);
            }

            const url = buildUrl();
            const resp = await fetch(url, { cache: 'no-store' });
            if (!resp.ok) return;
            const data = await resp.json();
            const pts = Array.isArray(data) ? data : (Array.isArray(data?.points) ? data.points : []);

            const pointsContainer = document.getElementById('pointsContainer');

            if (!pts.length) {
                clearMap();
                if (pointsContainer) pointsContainer.innerHTML = '';
                const pointsCountEl = document.getElementById('pointsCount');
                if (pointsCountEl) pointsCountEl.innerText = '0';
                return;
            }

            clearMap();

            const latlngs = [];
            if (pointsContainer) pointsContainer.innerHTML = '';

            // Create markers in the order returned by the API and keep a mapping
            const markerMapping = []; // { p, idx, lat, lon, createdDate }
            let markerIndex = 0;
            pts.forEach((p) => {
                const lat = toNum(p.Latitude ?? p.latitude ?? p.lat ?? p.latDeg ?? p.lat_deg);
                const lon = toNum(p.Longitude ?? p.longitude ?? p.lon ?? p.lonDeg ?? p.lon_deg);
                if (lat == null || lon == null) return;

                const myIdx = markerIndex++;
                latlngs.push([lat, lon]);

                const m = L.circleMarker([lat, lon], { radius: 5, color: '#1e88e5', fillColor: '#1e88e5', fillOpacity: 0.95 }).addTo(map);
                const createdRaw = p.CreatedAt ?? p.createdAt ?? p.timestamp ?? p.time ?? null;
                const createdDate = parseTimestamp(createdRaw);
                const createdText = createdDate ? formatLocal(createdDate) : null;
                m.bindPopup(`<div style="min-width:140px"><div><strong>Lat:</strong> ${lat}</div><div><strong>Lon:</strong> ${lon}</div>${createdDate ? `<div style='font-size:12px;color:#9aa4b2'>${formatLocal(createdDate)}</div>` : ''}</div>`);
                mapMarkers.push(m);

                m.on('click', () => { selectMarker(myIdx, true); });

                markerMapping.push({ p, idx: myIdx, lat, lon, createdDate, createdText });
            });

            // Sort mapping for sidebar list by CreatedAt DESC (newest first)
            const mappingForList = markerMapping.slice().sort((a, b) => {
                const ta = a.createdDate ? a.createdDate.getTime() : 0;
                const tb = b.createdDate ? b.createdDate.getTime() : 0;
                return tb - ta;
            });

            // Render sorted list in sidebar referencing correct marker indices
            if (pointsContainer) {
                pointsContainer.innerHTML = '';
                mappingForList.forEach(item => {
                    const { idx, lat, lon, createdText } = item;
                    const entry = document.createElement('div');
                    entry.className = 'point';
                    entry.dataset.index = String(idx);
                    entry.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700">${lat.toFixed(6)}, ${lon.toFixed(6)}</div><div style="font-size:11px;color:#9aa4b2">${createdText || '—'}</div></div>`;
                    entry.addEventListener('click', () => { selectMarker(idx, true); });
                    pointsContainer.appendChild(entry);
                });
            }

            const pointsCountEl = document.getElementById('pointsCount');
            if (pointsCountEl) pointsCountEl.innerText = String(mapMarkers.length);
         
             if (latlngs.length) {
                 mapPath = L.polyline(latlngs, { color: 'blue' }).addTo(map);
                 if (!didInitialFit) {
                     try {
                         if (latlngs.length === 1) {
                             map.setView(latlngs[0], 15);
                         } else {
                             map.fitBounds(latlngs);
                         }
                     } catch (e) { }
                     didInitialFit = true;
                 }
             }
         } catch (e) {
             console.error('loadPoints error', e);
         }
     }

    function selectMarker(idx, pan = false) {
        if (!Array.isArray(mapMarkers) || idx == null || idx < 0 || idx >= mapMarkers.length) return;
        if (selectedMarkerIndex != null && mapMarkers[selectedMarkerIndex]) {
            try { mapMarkers[selectedMarkerIndex].setStyle({ radius: 5, color: '#1e88e5', fillColor: '#1e88e5' }); } catch (e) {}
            const prevEl = document.querySelector(`#pointsContainer .point[data-index='${selectedMarkerIndex}']`);
            if (prevEl) prevEl.classList.remove('selected');
        }

        selectedMarkerIndex = idx;
        const marker = mapMarkers[idx];
        try { marker.setStyle({ radius: 8, color: '#ff9800', fillColor: '#ff9800' }); } catch (e) {}
        try { marker.openPopup(); } catch (e) {}

        const el = document.querySelector(`#pointsContainer .point[data-index='${idx}']`);
        if (el) {
            el.classList.add('selected');
            el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        if (pan) {
            try {
                const latlng = marker.getLatLng();
                map.setView([latlng.lat, latlng.lng], 15);
            } catch (e) {}
        }
    }

    const fromEl = document.getElementById('fromPicker');
    const toEl = document.getElementById('toPicker');
    [fromEl, toEl].forEach(el => {
        if (!el) return;
        el.dataset.auto = 'true';
        el.addEventListener('input', () => { el.dataset.auto = 'false'; el.dataset.userEdited = 'true'; });
        el.addEventListener('change', () => { el.dataset.auto = 'false'; el.dataset.userEdited = 'true'; loadPoints(); });
    });

    setDefaultRange();
    loadPoints();
    setInterval(loadPoints, 2000);

    const openBtn = document.getElementById('openSidebar');
    const sidebarEl = document.getElementById('sidebar');
    const backdropEl = document.getElementById('backdrop');

    function setDetailsButtonVisible(visible) {
        if (!openBtn) return;
        openBtn.style.display = visible ? '' : 'none';
    }

    if (openBtn && sidebarEl && backdropEl) {
        openBtn.addEventListener('click', () => {
            const willOpen = !sidebarEl.classList.contains('open');
            sidebarEl.classList.toggle('open');
            backdropEl.classList.toggle('open');
            if (willOpen) {
                sidebarEl.style.background = 'rgba(11,18,28,0.95)';
                sidebarEl.style.opacity = '1';
                sidebarEl.style.zIndex = '1202';
            }
            setDetailsButtonVisible(!willOpen);
        });

        const closeHandler = () => {
            sidebarEl.classList.remove('open');
            backdropEl.classList.remove('open');
            setDetailsButtonVisible(true);
        };

        const closeBtn = document.getElementById('closeSidebar');
        if (closeBtn) closeBtn.addEventListener('click', closeHandler);
        backdropEl.addEventListener('click', closeHandler);
    }

    const deleteBtn = document.getElementById('deleteAll');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', async () => {
            if (!confirm('Delete all points? This action cannot be undone.')) return;
            try {
                const resp = await fetch('/v1/public/location/points', { method: 'DELETE', cache: 'no-store' });
                if (resp.ok) {
                    // refresh the entire page to ensure UI + server are in sync
                    location.reload();
                } else {
                    alert('Failed to delete points: ' + resp.statusText);
                }
            } catch (e) { console.warn('delete error', e); alert('Delete failed'); }
        });
    }

    // Fetch device status periodically and populate the status section.
    async function fetchDeviceStatus() {
        try {
            const resp = await fetch('/v1/public/device', { cache: 'no-store' });
            if (!resp.ok) {
                // if endpoint not found or returns error, leave placeholders
                console.warn('fetchDeviceStatus: non-ok response', resp.status);
                return;
            }
            const data = await resp.json();
            let device;
             if (Array.isArray(data)) device = data[0] ?? null;
             else if (Array.isArray(data?.devices)) device = data.devices[0] ?? null;
             else device = data ?? null;

            const setText = (id, v) => {
                const el = document.getElementById(id);
                if (!el) return;
                el.innerText = (v === null || v === undefined) ? '—' : String(v);
            };
            const setBool = (id, v) => {
                const el = document.getElementById(id);
                if (!el) return;
                if (v === null || v === undefined) { el.innerText = '—'; el.classList.remove('status-true'); el.classList.remove('status-false'); return; }
                const bool = !!v;
                el.innerText = bool ? 'Yes' : 'No';
                el.classList.toggle('status-true', bool);
                el.classList.toggle('status-false', !bool);
            };

            if (!device) {
                // no device info available
                setText('BatteryLevel', '—');
                setBool('IsGPSOnline', null);
                setBool('IsInAlarm', null);
                setBool('IsButtonPressed', null);
                setBool('IsInCharge', null);
                const last = document.getElementById('lastFetched'); if (last) last.innerText = formatLocal(new Date());
                const statusUpdatedEl = document.getElementById('statusUpdated'); if (statusUpdatedEl) statusUpdatedEl.innerText = '';
                return;
            }

            const batteryVal = device.BatteryLevel ?? device.batteryLevel ?? device.battery ?? null;
            if (batteryVal === null || batteryVal === undefined) setText('BatteryLevel', '—');
            else setText('BatteryLevel', (typeof batteryVal === 'number') ? `${batteryVal}%` : String(batteryVal));

            setBool('IsGPSOnline', device.IsGPSOnline ?? device.isGPSOnline ?? device.gpsOnline ?? null);
            setBool('IsInAlarm', device.IsInAlarm ?? device.isInAlarm ?? device.inAlarm ?? null);
            setBool('IsButtonPressed', device.IsButtonPressed ?? device.isButtonPressed ?? device.buttonPressed ?? null);
            setBool('IsInCharge', device.IsInCharge ?? device.isInCharge ?? device.inCharge ?? null);

            // UpdatedAt: try to parse and display local time
            const rawUpdated = device.UpdatedAt ?? device.updatedAt ?? device.UpdatedAtUtc ?? device.updatedAtUtc ?? device.updatedAt;
            const updatedDate = parseTimestamp(rawUpdated) ?? new Date();
            const lastFetchedEl = document.getElementById('lastFetched');
            if (lastFetchedEl) lastFetchedEl.innerText = formatLocal(updatedDate);

            const statusUpdatedEl = document.getElementById('statusUpdated');
            if (statusUpdatedEl) statusUpdatedEl.innerText = '';
        } catch (e) {
            console.warn('fetchDeviceStatus error', e);
        }
    }

    // start polling device status every 2 seconds to keep UI current
    fetchDeviceStatus();
    setInterval(fetchDeviceStatus, 2000);

</script>
