@model DedicatedGeo.Mono.Dtos.Web.LocationPathViewDto

@{
    ViewBag.Title = Model.Title;
}

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
    html, body, #map { height: 100vh; margin: 0; padding: 0; }

    #openSidebar {
        position: absolute;
        top: 12px;
        right: 120px;
        /* place the Details button under the backdrop (backdrop z-index is 1100) */
        z-index: 1098;
        background: linear-gradient(135deg,#7c5cff,#5ab3ff);
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 600;
        font-family: sans-serif;
    }

    .sidebar-backdrop{
        position: fixed;
        inset: 0;
        /* increased opacity for a more visible backdrop */
        background: rgba(2,6,23,0.75);
        z-index: 1100;
        opacity: 0;
        pointer-events: none;
        transition: opacity .18s ease;
    }
    .sidebar-backdrop.open{
        opacity: 1;
        pointer-events: auto;
    }

    .sidebar{
        position: fixed;
        top: 0;
        right: 0;
        height: 100vh;
        width: min(520px, 92vw);
        background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
        box-shadow: -30px 0 60px rgba(2,6,23,0.6);
        transform: translateX(105%);
        transition: transform .28s cubic-bezier(.2,.9,.25,1);
        z-index: 1102;
        display: flex;
        flex-direction: column;
        padding: 18px;
        gap: 12px;
        font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        color: #e6eef8;
        border-left: 1px solid rgba(255,255,255,0.03);
    }
    .sidebar.open{ transform: translateX(0); }

    .sidebar-header{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .title{ display:flex; align-items:center; gap:12px; }
    .title .dot{ width:42px;height:42px;border-radius:10px; background: linear-gradient(135deg,#7c5cff,#5ab3ff); display:flex;align-items:center;justify-content:center;font-weight:700; }
    .title h3{ margin:0; font-size:16px; }
    .close-btn{ background:transparent;border:none;color:#9aa4b2;cursor:pointer;padding:8px;border-radius:8px; }

    /* stacked sections (no "zones" grid) */
    .section { background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.03)); border-radius:12px; padding:12px; border:1px solid rgba(255,255,255,0.03); }
    .section h4{ margin:0 0 8px 0; font-size:13px; color:#dfe8f7; display:flex;justify-content:space-between; align-items:center; }
    .section .count{ font-size:12px; color:#9aa4b2; }

    /* Points list: stack vertically, scrollable, cap at 70% of viewport height */
    .points-container{
        display:flex;
        flex-direction:column;
        gap:8px;
        overflow-y:auto;
        overflow-x:hidden;
        max-height:70vh; /* cap height to 70% of viewport */
        padding-bottom:6px;
        width:100%;
    }
    /* Groups will render as full-width stacked columns (JS can still populate 3 groups) */
    .group{
        width:100%;
        display:flex;
        flex-direction:column;
        gap:8px;
    }
    .point{ background: rgba(255,255,255,0.03); border-radius:8px; padding:8px; font-size:12px; color:#e6eef8; box-shadow:0 4px 14px rgba(4,6,12,0.35); border:1px solid rgba(255,255,255,0.02); }
    .point .meta{ color:#9aa4b2; font-size:11px; margin-top:6px; }

    .status-grid{ display:grid; grid-template-columns: repeat(2,1fr); gap:8px; margin-top:6px; }
    .status-item{ padding:10px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(0,0,0,0.04)); display:flex; flex-direction:column; gap:6px; font-size:13px; }
    .status-item .val{ font-weight:700; color:#fff; }
    .status-true{ color:#22c55e; font-weight:700; }
    .status-false{ color:#9aa4b2; font-weight:700; }

    .actions{ display:flex; gap:8px; align-items:center; }
    .btn{ padding:8px 12px; border-radius:9px; border:none; cursor:pointer; font-weight:600; }
    .btn.danger{ background: linear-gradient(180deg,#ef4444,#c81b1b); color:white; }

    /* datetime picker styled similar to sidebar */
    .datetime-row{ display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    .datetime-row label{ font-size:12px; color:#9aa4b2; margin-right:6px; }
    .datetime-input{ background: rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.04); color:#e6eef8; padding:8px; border-radius:8px; }
    .datetime-input::-webkit-calendar-picker-indicator{ filter:invert(1) grayscale(1); }

    @@media (max-width:560px){
        .points-container{ flex-direction:column; }
        .group{ min-width:unset; }
    }
</style>

<div id="map"></div>

<!-- Top-center datetime picker moved from the sidebar -->
<div id="pickerContainer" style="position:absolute;top:12px;left:50%;transform:translateX(-50%);z-index:1103;display:flex;align-items:center;gap:8px;background:rgba(11,18,28,0.85);padding:8px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);">
    <label for="fromPicker" style="font-size:12px;color:#9aa4b2;margin-right:6px;">From</label>
    <!-- step="1" enables seconds in datetime-local input -->
    <input id="fromPicker" class="datetime-input" type="datetime-local" step="1" />
    <label for="toPicker" style="font-size:12px;color:#9aa4b2;margin-right:6px;">To</label>
    <input id="toPicker" class="datetime-input" type="datetime-local" step="1" />
</div>

<button id="openSidebar">Details</button>

<div id="backdrop" class="sidebar-backdrop" aria-hidden="true"></div>

<aside id="sidebar" class="sidebar" aria-hidden="true">
    <div class="sidebar-header">
        <div class="title">
            <div class="dot">LP</div>
            <div>
                <h3>Location Points</h3>
                <div style="font-size:12px;color:#9aa4b2">Live point summary</div>
            </div>
        </div>
        <div class="actions">
            <button id="deleteAll" class="btn danger">Delete all points</button>
            <button id="closeSidebar" class="close-btn" title="Close">✕</button>
        </div>
    </div>

    <!-- Points section: groups are purely presentational (not strict "zones") -->
    <div class="section" id="pointsSection">
        <h4>Points <span id="pointsCount" class="count"></span></h4>

        <div class="points-container" id="pointsContainer">
        </div>
    </div>

    <!-- Status section -->
    <div class="section" id="statusSection">
        <h4>Status <span id="statusUpdated" class="count"></span></h4>
        <div class="status-grid" id="statusGrid">
            <div class="status-item">
                <div class="label">Battery</div>
                <div id="BatteryLevel" class="val">—</div>
            </div>
            <div class="status-item">
                <div class="label">GPS Online</div>
                <div id="IsGPSOnline" class="val status-false">—</div>
            </div>
            <div class="status-item">
                <div class="label">In Alarm</div>
                <div id="IsInAlarm" class="val status-false">—</div>
            </div>
            <div class="status-item">
                <div class="label">Button Pressed</div>
                <div id="IsButtonPressed" class="val status-false">—</div>
            </div>
            <div class="status-item" style="grid-column:1 / -1; display:flex; justify-content:space-between; align-items:center;">
                <div style="font-size:13px;color:#9aa4b2">Last fetched</div>
                <div id="lastFetched" style="font-size:12px;color:#9aa4b2">—</div>
            </div>
        </div>
    </div>
</aside>

<!-- scripts removed as requested -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    // Map initialization
    const map = L.map('map').setView([0,0],2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap contributors' }).addTo(map);

    // state
    let mapMarkers = [];
    let mapPath = null;

    // helpers
    const toNum = v => { if (v === undefined || v === null) return null; const n = Number(String(v).replace(',', '.')); return Number.isFinite(n) ? n : null; };

    // produce a datetime-local string like YYYY-MM-DDTHH:mm:ss
    function toDateTimeLocal(dt) {
        const pad = n => String(n).padStart(2, '0');
        return `${dt.getFullYear()}-${pad(dt.getMonth()+1)}-${pad(dt.getDate())}T${pad(dt.getHours())}:${pad(dt.getMinutes())}:${pad(dt.getSeconds())}`;
    }

    // convert datetime-local (local time) to ISO string (UTC) for API
    function localToISOString(localValue) {
        if (!localValue) return '';
        const m = localValue.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})(?::(\d{2}))?$/);
        if (!m) return new Date(localValue).toISOString();
        const y = Number(m[1]); const mo = Number(m[2]) - 1; const d = Number(m[3]);
        const hh = Number(m[4]); const mm = Number(m[5]); const ss = Number(m[6] || '0');
        const dt = new Date(y, mo, d, hh, mm, ss);
        return dt.toISOString();
    }

    // set default time range: now-1h .. now, mark inputs as auto so they advance unless user edits
    function setDefaultRange() {
        const now = new Date();
        const oneHourAgo = new Date(now.getTime() - 60*60*1000);
        const fromEl = document.getElementById('fromPicker');
        const toEl = document.getElementById('toPicker');
        if (fromEl && toEl) {
            if (!fromEl.dataset.userEdited) fromEl.value = toDateTimeLocal(oneHourAgo);
            if (!toEl.dataset.userEdited) toEl.value = toDateTimeLocal(now);
            if (!fromEl.dataset.userEdited) fromEl.dataset.auto = 'true';
            if (!toEl.dataset.userEdited) toEl.dataset.auto = 'true';
        }
    }

    // build the API URL using current datetime inputs (convert to ISO)
    function buildUrl() {
        let url = '/v1/public/location/points';
        const params = [];
        const fromEl = document.getElementById('fromPicker');
        const toEl = document.getElementById('toPicker');
        if (fromEl && fromEl.value) {
            const iso = localToISOString(fromEl.value);
            if (iso) params.push('from=' + encodeURIComponent(iso));
        }
        if (toEl && toEl.value) {
            const iso = localToISOString(toEl.value);
            if (iso) params.push('to=' + encodeURIComponent(iso));
        }
        if (params.length) url += '?' + params.join('&');
        return url;
    }

    // clear markers and polyline
    function clearMap() {
        mapMarkers.forEach(m => { try { map.removeLayer(m); } catch(e) {} });
        mapMarkers = [];
        if (mapPath) { try { map.removeLayer(mapPath); } catch(e) {} mapPath = null; }
    }

    // fetch points and render them
    async function loadPoints() {
        try {
            // if both pickers are still auto, advance them before fetch so default window follows time
            const fromEl = document.getElementById('fromPicker');
            const toEl = document.getElementById('toPicker');
            const now = new Date();
            if (fromEl && toEl && fromEl.dataset.auto === 'true' && toEl.dataset.auto === 'true') {
                const oneHourAgo = new Date(now.getTime() - 60*60*1000);
                fromEl.value = toDateTimeLocal(oneHourAgo);
                toEl.value = toDateTimeLocal(now);
            } else if (toEl && toEl.dataset.auto === 'true') {
                toEl.value = toDateTimeLocal(now);
            }

            const url = buildUrl();
            const resp = await fetch(url, { cache: 'no-store' });
            if (!resp.ok) return;
            const data = await resp.json();
            // support both array response and { points: [...] }
            const pts = Array.isArray(data) ? data : (Array.isArray(data?.points) ? data.points : []);
            if (!pts.length) { clearMap(); return; }

            clearMap();

            const latlngs = [];
            pts.forEach(p => {
                const lat = toNum(p.Latitude ?? p.latitude ?? p.lat ?? p.latDeg ?? p.lat_deg);
                const lon = toNum(p.Longitude ?? p.longitude ?? p.lon ?? p.lonDeg ?? p.lon_deg);
                if (lat == null || lon == null) return;
                latlngs.push([lat, lon]);
                const m = L.circleMarker([lat, lon], { radius: 5, color: '#1e88e5', fillColor: '#1e88e5', fillOpacity: 0.95 }).addTo(map);
                const created = p.CreatedAt ?? p.createdAt ?? p.timestamp ?? p.time ?? null;
                m.bindPopup(`<div style="min-width:140px"><div><strong>Lat:</strong> ${lat}</div><div><strong>Lon:</strong> ${lon}</div>${created ? `<div style='font-size:12px;color:#9aa4b2'>${new Date(created).toLocaleString()}</div>` : ''}</div>`);
                mapMarkers.push(m);
            });

            if (latlngs.length) {
                mapPath = L.polyline(latlngs, { color: 'blue' }).addTo(map);
                try { map.fitBounds(latlngs); } catch(e) { /* ignore */ }
            }
        } catch (e) {
            console.error('loadPoints error', e);
        }
    }

    // wire up pickers: mark user-edited and prevent auto-advance
    const fromEl = document.getElementById('fromPicker');
    const toEl = document.getElementById('toPicker');
    [fromEl, toEl].forEach(el => {
        if (!el) return;
        el.dataset.auto = 'true';
        el.addEventListener('input', () => { el.dataset.auto = 'false'; el.dataset.userEdited = 'true'; loadPoints(); });
    });

    // set initial default range and start 2s polling
    setDefaultRange();
    loadPoints();
    setInterval(loadPoints, 2000);

    // keep minimal sidebar handlers
    document.getElementById('openSidebar').addEventListener('click', () => { document.getElementById('sidebar').classList.toggle('open'); document.getElementById('backdrop').classList.toggle('open'); });
    document.getElementById('closeSidebar').addEventListener('click', () => { document.getElementById('sidebar').classList.remove('open'); document.getElementById('backdrop').classList.remove('open'); });

    // close sidebar when clicking outside of it
    document.getElementById('backdrop').addEventListener('click', () => { document.getElementById('sidebar').classList.remove('open'); document.getElementById('backdrop').classList.remove('open'); });

    // delete handler (keeps existing behavior)
    document.getElementById('deleteAll').addEventListener('click', async () => {
        if (!confirm('Delete all points? This action cannot be undone.')) return;
        try { await fetch('/v1/public/location/points', { method: 'DELETE', cache: 'no-store' }); loadPoints(); } catch (e) { console.warn('delete error', e); }
    });
</script>
